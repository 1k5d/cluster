#include "cluster.h"

int main (int argc, char* argv[])
{
	double t0 = time(NULL);
	//Проверяем наличие файла "cluster.inp" и читаем из него данные в массив values
	double values[7];
	if (read_input (values))
	{
		std::cout << "Error! File \"cluster.inp\" does not exist." << std::endl;
		return 0;
	}

	//Переписываем данные из файла в свои переменные
	double average_radius = values[0]; //Средний радиус частиц
	double sigma = values[1]; //Дисперсия по размерам частиц
	double shell = values[2]; //Толщина оболочки
	double k0 = values[3]; //Константа скорости для гибели возбуждения
	double phi = values[4]; //Квантовый выход частиц
	double vphi = values[5]; //Доля люминесцирующих частиц
	double cdse = values[6]; //1, если изучаем CdSe, 0 если нет
	std::ostringstream name_file_ksi2_o, name_file_delta_o;
	name_file_ksi2_o << "ksi2-dim=" << dimension
			<< "-r=" << values[0]
			<< "-sig=" << values[1]
			<< "-l=" << values[2]
			<< "-k=" << values[3]
			<< "-phi=" << values[4]
			<< "-vphi=" << values[5] << ".txt";
	name_file_delta_o << "delta-dim=" << dimension
			<< "-r=" << values[0]
			<< "-sig=" << values[1]
			<< "-l=" << values[2]
			<< "-k=" << values[3]
			<< "-phi=" << values[4]
			<< "-vphi=" << values[5] << ".txt";
	std::string name_file_ksi2 = name_file_ksi2_o.str();
	std::string name_file_delta = name_file_delta_o.str();

	//Главный массив с координатами всех частиц, радиусами, номером частицы с возбуждением
	//Структура массива
	//0 элемент: количество частиц на данный момент
	//1 элемент: номер частицы, на которой сейчас возбуждение
	//6i+2 элемент: радиус частицы с номером i, начиная с 0
	//6i+3 элемент: X-координата частицы с номером i
	//6i+4 элемент: Y-координата частицы с номером i
	//6i+5 элемент: Z-координата частицы с номером i
	//6i+6 элемент: показывает, если или нет (0 или 1) возбуждение на частице с номером i
	//6i+7 элемент: показывает, люминесцирует (1) или нет (0) частица с номером i
	static double main_array[number_of_dots*6+2];

	//Двумерный массив, показывающий для каждой частицы номера частиц из ближайшего окружения
	//В этот список должны попасть все частицы, касающиеся частицы с номером i
	//Попадание частиц, не касающихся частицы с номером i, допустимо. Это немного замедлит работу
	//
	//Струтктура массива
	//[i][0] элемент: число ближайших соседей у частицы с номером i
	//[i][1] элемент: номер первого соседа у частицы с номером i
	//...
	//[i][...] номер последнего элемента равен [i][0] элементу: номер последнего соседа у частицы i
	//Возбуждение передаётся на одну из частиц из этого списка
	static int neighbors[number_of_dots][N1];

	//Этот массив устроен аналогично предыдущему, только список соседей немного расширен
	//В этот список должны попасть все частицы, которые может пересекать новая сфера, касающаяся
	//частицы с номером i. Своего рода это двойная оболочка для частицы с номером i
	static int neighbors2[number_of_dots][N2];

	//Массив с заранее вычисленными радиусами Фёрстера для пар частиц CdSe
	//Структура массива
	//3i+0 элемент: радиус донора
	//3i+1 элемент: радиус акцептора
	//3i+2 элемент: радиус Фёрстера для этой пары донор--акцептор
	//Для CdSe радиусы меняются от 1.08561 до 2.40735 нм с шагом 1/400 (всего 401 точка)
	//Сначала увеличиваются радиусы акцептора и постепенно увеличиваются радиусы донора
	double rf6_cdse[401*401*3];
	//Для InP радиусы меняются в диапазоне от 1.487189 до 1.996367 с шагом 1/200 от разности
	double rf6_inp[201*201*3];

	//10000 -- общее число точек на шкале времени, для которых вычисляется среднеквадратичное
	//смещение. Шаг по времени одинаковый и стандартный. Все траектории приводятся к этому шагу.
	//Для отдельной траектории вычисляется массив std_ksi2[10000]
	//Затем все траектории суммируются и суммарная траектория попадает в массив all_ksi2[10000]
	//Если возбуждение погибло на каком-то шаге, достигнув в конце жизни среднеквадратичного
	//смещения, но всем остальным шагам приписывается это последнее смещение вместо 0. В итоге
	//смещение монотонно возрастает, постепенно выходя на плато.
	//Начальные значения массива равны 0
	double all_ksi2[10000], all_delta_peak_fg[10000];
	for (int i = 0; i < 10000; i++)
	{
		all_ksi2[i] = 0.;
		all_delta_peak_fg[i] = 0.;
	}

	if (cdse > 0.5)
	{
		//Читаем файл "rf_cdse.txt" с радиусами Фёрстера для CdSe
		read_rf6 (rf6_cdse, cdse);
	}
	else
	{
		//Читаем файл "rf_inp.txt" с радиусами Фёрстера для InP
		read_rf6 (rf6_inp, cdse);
	}

	//Если размерность 1
	if (dimension == 1)
	{
		//100.000 траекторий для линейного кластера
		for (int i = 0; i < 100000; i++)
		{
			//Генерация радиусов всех частиц.
			//В одномерном случае происходит новая генерация радиусов на каждой траектории
			generate_dots (main_array, average_radius, sigma, cdse, i);

			//Генерация кластера
			//В одномерном случае кластер генерируется заново для каждой траектории
			generate_cluster (main_array, average_radius, shell, neighbors, neighbors2, values);

			//Инициация возбуждения на частицу с номером 0
			init_probabilities (main_array, 0);

			//Покраска доли частиц в чёрный цвет (нелюминесцирующие частицы)
			//Доля белых частиц равна vphi
			init_black (main_array, vphi, i);

			//Прогон возбуждения по массиву на заданное число шагов
			//Если возбуждение погибает раньше, то среднеквадратичное смещение фиксируется
			//то есть всем остальным шагам приписывается последнее смещение вместо 0
			//По мере накопления траекторий постепенно заполняется массив all_ksi2
			if (cdse > 0.5)
			{
				go_probabilities (main_array, neighbors, rf6_cdse, all_ksi2, k0, phi, cdse, all_delta_peak_fg, i);
			}
			else
			{
				go_probabilities (main_array, neighbors, rf6_inp, all_ksi2, k0, phi, cdse, all_delta_peak_fg, i);
			}
		}
	}
	//Если размерность 2 или 3
	else
	{
		//Генерация радиусов всех частиц
		//Для размерности 2 и 3 происходит генерация радиусов 1 раз
		generate_dots (main_array, average_radius, sigma, cdse, 0);

		//Генерация кластера
		//Для размерности 2 и 3 кластер генерируется 1 раз
		generate_cluster (main_array, average_radius, shell, neighbors, neighbors2, values);

		//10.000 число траекторий для размерности 2 и 3
		for (int i = 0; i < 10000; i++)
		{
			//Работа этой функции аналогична одномерному случаю
			init_probabilities (main_array, 0);

			//Покраска доли частиц в чёрный цвет (нелюминесцирующие частицы)
			//Доля белых частиц равна vphi
			init_black (main_array, vphi, i);

			if (cdse > 0.5)
			{
				//Работа этой функции аналогична одномерному случаю
				go_probabilities (main_array, neighbors, rf6_cdse, all_ksi2, k0, phi, cdse, all_delta_peak_fg, i);
			}
			else
			{
				//Работа этой функции аналогична одномерному случаю
				go_probabilities (main_array, neighbors, rf6_inp, all_ksi2, k0, phi, cdse, all_delta_peak_fg, i);
			}
		}
	}

	//Делим среднеквадратичное смещение на количество траекторий, по которым усредняли
	//100.000 для одномерного случая
	//10.000 для размерности 2 и 3
	FILE *fksi2, *fdelta;
	if ((fksi2 = fopen (name_file_ksi2.c_str(), "wt")) == NULL)
	{
		std::cout << "File " << name_file_ksi2 << " is not created" << std::endl;
	}
	if ((fdelta = fopen (name_file_delta.c_str(), "wt")) == NULL)
	{
		std::cout << "File " << name_file_delta << " is not created" << std::endl;
	}
	for (int i = 1; i < 10000; i++)
	{
		if (dimension > 1)
		{
			all_ksi2[i] *= 1e-4;
			all_delta_peak_fg[i] *= 1e-4;
		}
		else
		{
			all_ksi2[i] *= 1e-5;
			all_delta_peak_fg[i] *= 1e-5;
		}

		//Печать значений
		//Столбец 1 -- время
		//Столбец 2 -- усреднённое по всем траекториям среднеквадратичное смещение
		//Коэффициенты подобраны для удобного построения графика в ТеХ
		//0.001 переводит время в десятки нс (шкала от 0 до 5 десятков нс)
		//0.0001 переводит кв.нм в десятки тысяч кв.нм (шкала от 0 до 3 дес.тыс. кв.нм.)
		if (all_ksi2[i] && (i%4 == 0))
		{
			fprintf (fksi2, "%f %f\n", i*5e-4, all_ksi2[i]*1e-4);
			fprintf (fdelta, "%f %f\n", i*5e-4, all_delta_peak_fg[i]);
		}
	}
	fclose (fksi2);
	fclose (fdelta);

	//Завершение работы программы
	std::cout << "Время работы программы " << time(NULL)-t0 << " сек." << std::endl;
	return 0;
}
